From b58b08e4974431552126985a7ae8d874477aea74 Mon Sep 17 00:00:00 2001
From: Oleksandr Grytsov <oleksandr_grytsov@epam.com>
Date: Fri, 21 Dec 2018 14:14:09 +0200
Subject: [PATCH] [dataadapter] Make storageadapter and
 telemetryemulatoradapter builtin

Currently yocto go layer doesn't support plugin buildmode. In this commit
storageadapter and telemetryemulatoradapter are built as part of vis.

Signed-off-by: Oleksandr Grytsov <oleksandr_grytsov@epam.com>

diff --git a/dataadapter/storageadapter/storageadapter.go b/dataadapter/storageadapter/storageadapter.go
new file mode 100644
index 000000000000..118c853b6b9a
--- /dev/null
+++ b/src/gitpct.epam.com/epmd-aepr/aos_vis/dataadapter/storageadapter/storageadapter.go
@@ -0,0 +1,96 @@
+package storageadapter
+
+import (
+	"bytes"
+	"encoding/json"
+
+	log "github.com/sirupsen/logrus"
+	"gitpct.epam.com/epmd-aepr/aos_vis/dataadapter"
+)
+
+/*******************************************************************************
+ * Types
+ ******************************************************************************/
+
+// StorageAdapter storage adapter
+type StorageAdapter struct {
+	baseAdapter *dataadapter.BaseAdapter
+}
+
+/*******************************************************************************
+ * Public
+ ******************************************************************************/
+
+// NewAdapter creates adapter instance
+func NewAdapter(configJSON []byte) (adapter dataadapter.DataAdapter, err error) {
+	log.Info("Create storage adapter")
+
+	localAdapter := new(StorageAdapter)
+
+	localAdapter.baseAdapter, err = dataadapter.NewBaseAdapter()
+	if err != nil {
+		return nil, err
+	}
+
+	localAdapter.baseAdapter.Name = "StorageAdapter"
+
+	var sensors struct {
+		Data map[string]*dataadapter.BaseData
+	}
+
+	// Parse config
+	decoder := json.NewDecoder(bytes.NewReader(configJSON))
+	decoder.UseNumber()
+	if err = decoder.Decode(&sensors); err != nil {
+		return nil, err
+	}
+
+	localAdapter.baseAdapter.Data = sensors.Data
+
+	return localAdapter, nil
+}
+
+// GetName returns adapter name
+func (adapter *StorageAdapter) GetName() (name string) {
+	return adapter.baseAdapter.GetName()
+}
+
+// GetPathList returns list of all pathes for this adapter
+func (adapter *StorageAdapter) GetPathList() (pathList []string, err error) {
+	return adapter.baseAdapter.GetPathList()
+}
+
+// IsPathPublic returns true if requested data accessible without authorization
+func (adapter *StorageAdapter) IsPathPublic(path string) (result bool, err error) {
+	return adapter.baseAdapter.IsPathPublic(path)
+}
+
+// GetData returns data by path
+func (adapter *StorageAdapter) GetData(pathList []string) (data map[string]interface{}, err error) {
+	return adapter.baseAdapter.GetData(pathList)
+}
+
+// SetData sets data by pathes
+func (adapter *StorageAdapter) SetData(data map[string]interface{}) (err error) {
+	return adapter.baseAdapter.SetData(data)
+}
+
+// GetSubscribeChannel returns channel on which data changes will be sent
+func (adapter *StorageAdapter) GetSubscribeChannel() (channel <-chan map[string]interface{}) {
+	return adapter.baseAdapter.SubscribeChannel
+}
+
+// Subscribe subscribes for data changes
+func (adapter *StorageAdapter) Subscribe(pathList []string) (err error) {
+	return adapter.baseAdapter.Subscribe(pathList)
+}
+
+// Unsubscribe unsubscribes from data changes
+func (adapter *StorageAdapter) Unsubscribe(pathList []string) (err error) {
+	return adapter.baseAdapter.Unsubscribe(pathList)
+}
+
+// UnsubscribeAll unsubscribes from all data changes
+func (adapter *StorageAdapter) UnsubscribeAll() (err error) {
+	return adapter.baseAdapter.UnsubscribeAll()
+}
diff --git a/dataadapter/storageadapter/storageadapter_test.go b/dataadapter/storageadapter/storageadapter_test.go
new file mode 100644
index 000000000000..b0275f445bcd
--- /dev/null
+++ b/src/gitpct.epam.com/epmd-aepr/aos_vis/dataadapter/storageadapter/storageadapter_test.go
@@ -0,0 +1,133 @@
+package storageadapter_test
+
+import (
+	"os"
+	"testing"
+
+	log "github.com/sirupsen/logrus"
+
+	"gitpct.epam.com/epmd-aepr/aos_vis/dataadapter/storageadapter"
+	"gitpct.epam.com/epmd-aepr/aos_vis/dataadaptertest"
+)
+
+/*******************************************************************************
+ * Var
+ ******************************************************************************/
+
+var (
+	adapterInfo dataadaptertest.TestAdapterInfo
+)
+
+/*******************************************************************************
+ * Init
+ ******************************************************************************/
+
+func init() {
+	log.SetFormatter(&log.TextFormatter{
+		DisableTimestamp: false,
+		TimestampFormat:  "2006-01-02 15:04:05.000",
+		FullTimestamp:    true})
+	log.SetLevel(log.DebugLevel)
+	log.SetOutput(os.Stdout)
+}
+
+/*******************************************************************************
+ * Main
+ ******************************************************************************/
+
+func TestMain(m *testing.M) {
+	configJSON := `{"Data": {
+		"Attribute.Vehicle.VehicleIdentification.VIN":    {"Value": "TestVIN", "Public": true,"ReadOnly": true},
+		"Attribute.Vehicle.UserIdentification.Users":     {"Value": ["User1", "Provider1"], "Public": true},
+
+		"Signal.Drivetrain.InternalCombustionEngine.RPM": {"Value": 1000, "ReadOnly": true},
+
+		"Signal.Body.Trunk.IsLocked":                     {"Value": false},
+		"Signal.Body.Trunk.IsOpen":                       {"Value": true},
+
+		"Signal.Cabin.Door.Row1.Right.IsLocked":          {"Value": true},
+		"Signal.Cabin.Door.Row1.Right.Window.Position":   {"Value": 50},
+		"Signal.Cabin.Door.Row1.Left.IsLocked":           {"Value": true},
+		"Signal.Cabin.Door.Row1.Left.Window.Position":    {"Value": 23},
+		"Signal.Cabin.Door.Row2.Right.IsLocked":          {"Value": false},
+		"Signal.Cabin.Door.Row2.Right.Window.Position":   {"Value": 100},
+		"Signal.Cabin.Door.Row2.Left.IsLocked":           {"Value": true},
+		"Signal.Cabin.Door.Row2.Left.Window.Position":    {"Value": 0}
+	}}`
+
+	storageAdapter, err := storageadapter.NewAdapter([]byte(configJSON))
+	if err != nil {
+		log.Fatalf("Can't create storage adapter: %s", err)
+	}
+
+	adapterInfo = dataadaptertest.TestAdapterInfo{
+		Name:        "StorageAdapter",
+		PathListLen: 13,
+		Adapter:     storageAdapter,
+		SetData: map[string]interface{}{
+			"Signal.Cabin.Door.Row1.Right.IsLocked":        true,
+			"Signal.Cabin.Door.Row1.Right.Window.Position": 200,
+			"Signal.Cabin.Door.Row1.Left.IsLocked":         false,
+			"Signal.Cabin.Door.Row1.Left.Window.Position":  100,
+			"Signal.Cabin.Door.Row2.Right.IsLocked":        true,
+			"Signal.Cabin.Door.Row2.Right.Window.Position": 400,
+			"Signal.Cabin.Door.Row2.Left.IsLocked":         false,
+			"Signal.Cabin.Door.Row2.Left.Window.Position":  50},
+		SubscribeList: []string{
+			"Signal.Cabin.Door.Row1.Right.IsLocked",
+			"Signal.Cabin.Door.Row1.Right.Window.Position",
+			"Signal.Cabin.Door.Row1.Left.IsLocked",
+			"Signal.Cabin.Door.Row1.Left.Window.Position",
+			"Signal.Cabin.Door.Row2.Right.IsLocked",
+			"Signal.Cabin.Door.Row2.Right.Window.Position",
+			"Signal.Cabin.Door.Row2.Left.IsLocked",
+			"Signal.Cabin.Door.Row2.Left.Window.Position"},
+		SetSubscribeData: map[string]interface{}{
+			"Signal.Cabin.Door.Row1.Right.IsLocked":        false,
+			"Signal.Cabin.Door.Row1.Right.Window.Position": 100,
+			"Signal.Cabin.Door.Row1.Left.IsLocked":         true,
+			"Signal.Cabin.Door.Row1.Left.Window.Position":  50,
+			"Signal.Cabin.Door.Row2.Right.IsLocked":        false,
+			"Signal.Cabin.Door.Row2.Right.Window.Position": 60,
+			"Signal.Cabin.Door.Row2.Left.IsLocked":         true,
+			"Signal.Cabin.Door.Row2.Left.Window.Position":  70},
+	}
+
+	ret := m.Run()
+
+	os.Exit(ret)
+}
+
+/*******************************************************************************
+ * Tests
+ ******************************************************************************/
+
+func TestGetName(t *testing.T) {
+	if err := dataadaptertest.GetName(&adapterInfo); err != nil {
+		t.Errorf("Test get name error: %s", err)
+	}
+}
+
+func TestGetPathList(t *testing.T) {
+	if err := dataadaptertest.GetPathList(&adapterInfo); err != nil {
+		t.Errorf("Test get path lis error: %s", err)
+	}
+}
+
+func TestPublicPath(t *testing.T) {
+	if err := dataadaptertest.PublicPath(&adapterInfo); err != nil {
+		t.Errorf("Test public path error: %s", err)
+	}
+}
+
+func TestGetSetData(t *testing.T) {
+	if err := dataadaptertest.GetSetData(&adapterInfo); err != nil {
+		t.Errorf("Test get set data error: %s", err)
+	}
+}
+
+func TestSubscribeUnsubscribe(t *testing.T) {
+	if err := dataadaptertest.SubscribeUnsubscribe(&adapterInfo); err != nil {
+		t.Errorf("Test subscribe unsubscribe error: %s", err)
+	}
+}
diff --git a/dataadapter/telemetryemulatoradapter/telemetryemulatoradapter.go b/dataadapter/telemetryemulatoradapter/telemetryemulatoradapter.go
new file mode 100644
index 000000000000..728858d15dae
--- /dev/null
+++ b/src/gitpct.epam.com/epmd-aepr/aos_vis/dataadapter/telemetryemulatoradapter/telemetryemulatoradapter.go
@@ -0,0 +1,263 @@
+package telemetryemulatoradapter
+
+import (
+	"bytes"
+	"encoding/json"
+	"errors"
+	"fmt"
+	"io/ioutil"
+	"net/http"
+	"net/url"
+	"strings"
+	"time"
+
+	log "github.com/sirupsen/logrus"
+	"gitpct.epam.com/epmd-aepr/aos_vis/dataadapter"
+)
+
+/*******************************************************************************
+ * Types
+ ******************************************************************************/
+
+const (
+	defaultUpdatePeriod = 500
+)
+
+// TelemetryEmulatorAdapter sensor emulator adapter
+type TelemetryEmulatorAdapter struct {
+	sensorURL    *url.URL
+	updatePeriod uint64
+
+	baseAdapter *dataadapter.BaseAdapter
+}
+
+type config struct {
+	SensorURL    string
+	UpdatePeriod uint64
+}
+
+/*******************************************************************************
+ * Public
+ ******************************************************************************/
+
+// NewAdapter creates adapter instance
+func NewAdapter(configJSON []byte) (adapter dataadapter.DataAdapter, err error) {
+	log.Info("Create telemetry emulator adapter")
+
+	localAdapter := new(TelemetryEmulatorAdapter)
+
+	cfg := config{UpdatePeriod: defaultUpdatePeriod}
+
+	// Parse config
+	err = json.Unmarshal(configJSON, &cfg)
+	if err != nil {
+		return nil, err
+	}
+
+	if cfg.SensorURL == "" {
+		return nil, errors.New("Sensor URL should be defined")
+	}
+
+	localAdapter.updatePeriod = cfg.UpdatePeriod
+	localAdapter.sensorURL, err = url.Parse(cfg.SensorURL)
+
+	if localAdapter.baseAdapter, err = dataadapter.NewBaseAdapter(); err != nil {
+		return nil, err
+	}
+
+	localAdapter.baseAdapter.Name = "TelemetryEmulatorAdapter"
+
+	// Create data map
+	data, err := localAdapter.getDataFromTelemetryEmulator()
+	if err != nil {
+		return nil, err
+	}
+	for path, value := range data {
+		localAdapter.baseAdapter.Data[path] = &dataadapter.BaseData{Value: value}
+	}
+
+	// Create attributes
+	localAdapter.baseAdapter.Data["Attribute.Emulator.rectangle_long0"] = &dataadapter.BaseData{}
+	localAdapter.baseAdapter.Data["Attribute.Emulator.rectangle_lat0"] = &dataadapter.BaseData{}
+	localAdapter.baseAdapter.Data["Attribute.Emulator.rectangle_long1"] = &dataadapter.BaseData{}
+	localAdapter.baseAdapter.Data["Attribute.Emulator.rectangle_lat1"] = &dataadapter.BaseData{}
+	localAdapter.baseAdapter.Data["Attribute.Emulator.to_rectangle"] = &dataadapter.BaseData{}
+	localAdapter.baseAdapter.Data["Attribute.Emulator.stop"] = &dataadapter.BaseData{}
+	localAdapter.baseAdapter.Data["Attribute.Emulator.tire_break"] = &dataadapter.BaseData{}
+
+	go localAdapter.processData()
+
+	return localAdapter, nil
+}
+
+/*******************************************************************************
+ * Public
+ ******************************************************************************/
+
+// GetName returns adapter name
+func (adapter *TelemetryEmulatorAdapter) GetName() (name string) {
+	return adapter.baseAdapter.GetName()
+}
+
+// GetPathList returns list of all pathes for this adapter
+func (adapter *TelemetryEmulatorAdapter) GetPathList() (pathList []string, err error) {
+	return adapter.baseAdapter.GetPathList()
+}
+
+// IsPathPublic returns true if requested data accessible without authorization
+func (adapter *TelemetryEmulatorAdapter) IsPathPublic(path string) (result bool, err error) {
+	adapter.baseAdapter.Mutex.Lock()
+	defer adapter.baseAdapter.Mutex.Unlock()
+
+	// TODO: return false, once authorization is integrated
+
+	return true, nil
+}
+
+// GetData returns data by path
+func (adapter *TelemetryEmulatorAdapter) GetData(pathList []string) (data map[string]interface{}, err error) {
+	return adapter.baseAdapter.GetData(pathList)
+}
+
+// SetData sets data by pathes
+func (adapter *TelemetryEmulatorAdapter) SetData(data map[string]interface{}) (err error) {
+	sendData, err := convertVisFormatToData(data)
+	if err != nil {
+		return err
+	}
+
+	path, err := url.Parse("attributes/")
+	if err != nil {
+		return err
+	}
+
+	address := adapter.sensorURL.ResolveReference(path).String()
+
+	log.WithField("url", address).Debugf("Set data to sensor emulator: %s", string(sendData))
+
+	res, err := http.Post(address, "application/json", bytes.NewReader(sendData))
+	if err != nil {
+		return err
+	}
+	if res.StatusCode != 201 {
+		return errors.New(res.Status)
+	}
+
+	return adapter.baseAdapter.SetData(data)
+}
+
+// GetSubscribeChannel returns channel on which data changes will be sent
+func (adapter *TelemetryEmulatorAdapter) GetSubscribeChannel() (channel <-chan map[string]interface{}) {
+	return adapter.baseAdapter.SubscribeChannel
+}
+
+// Subscribe subscribes for data changes
+func (adapter *TelemetryEmulatorAdapter) Subscribe(pathList []string) (err error) {
+	return adapter.baseAdapter.Subscribe(pathList)
+}
+
+// Unsubscribe unsubscribes from data changes
+func (adapter *TelemetryEmulatorAdapter) Unsubscribe(pathList []string) (err error) {
+	return adapter.baseAdapter.Unsubscribe(pathList)
+}
+
+// UnsubscribeAll unsubscribes from all data changes
+func (adapter *TelemetryEmulatorAdapter) UnsubscribeAll() (err error) {
+	return adapter.baseAdapter.UnsubscribeAll()
+}
+
+/*******************************************************************************
+ * Private
+ ******************************************************************************/
+
+func parseNode(prefix string, element interface{}) (visData map[string]interface{}) {
+	visData = make(map[string]interface{})
+
+	m, ok := element.(map[string]interface{})
+	if ok {
+		for path, value := range m {
+			for visPath, visValue := range parseNode(prefix+"."+path, value) {
+				visData[visPath] = visValue
+			}
+		}
+	} else {
+		visData[prefix] = element
+	}
+
+	return visData
+}
+
+func convertDataToVisFormat(dataJSON []byte) (visData map[string]interface{}, err error) {
+	var data interface{}
+
+	err = json.Unmarshal(dataJSON, &data)
+	if err != nil {
+		return visData, err
+	}
+
+	visData = parseNode("Signal.Emulator", data)
+
+	return visData, nil
+}
+
+func (adapter *TelemetryEmulatorAdapter) getDataFromTelemetryEmulator() (visData map[string]interface{}, err error) {
+	path, err := url.Parse("stats")
+	if err != nil {
+		return visData, err
+	}
+
+	address := adapter.sensorURL.ResolveReference(path).String()
+
+	res, err := http.Get(address)
+	if err != nil {
+		return visData, err
+	}
+
+	data, err := ioutil.ReadAll(res.Body)
+	res.Body.Close()
+	if err != nil {
+		return visData, err
+	}
+
+	log.WithField("url", address).Debugf("Get data from sensor emulator: %s", string(data))
+
+	return convertDataToVisFormat(data)
+}
+
+func (adapter *TelemetryEmulatorAdapter) processData() {
+	ticker := time.NewTicker(time.Duration(adapter.updatePeriod) * time.Millisecond)
+	for {
+		select {
+		case <-ticker.C:
+			data, err := adapter.getDataFromTelemetryEmulator()
+			if err != nil {
+				log.Errorf("Can't read data: %s", err)
+				continue
+			}
+			if err = adapter.baseAdapter.SetData(data); err != nil {
+				log.Errorf("Can't update data: %s", err)
+				continue
+			}
+		}
+	}
+}
+
+func convertVisFormatToData(visData map[string]interface{}) (dataJSON []byte, err error) {
+	sendData := make(map[string]interface{})
+
+	for path, value := range visData {
+		if strings.HasPrefix(path, "Attribute.Emulator.") {
+			path = strings.TrimPrefix(path, "Attribute.Emulator.")
+			sendData[path] = value
+		} else {
+			return dataJSON, fmt.Errorf("Path %s does not exist", path)
+		}
+	}
+
+	dataJSON, err = json.Marshal(&sendData)
+	if err != nil {
+		return dataJSON, err
+	}
+
+	return dataJSON, nil
+}
diff --git a/dataadapter/telemetryemulatoradapter/telemetryemulatoradapter_test.go b/dataadapter/telemetryemulatoradapter/telemetryemulatoradapter_test.go
new file mode 100644
index 000000000000..1d894a056b65
--- /dev/null
+++ b/src/gitpct.epam.com/epmd-aepr/aos_vis/dataadapter/telemetryemulatoradapter/telemetryemulatoradapter_test.go
@@ -0,0 +1,168 @@
+package telemetryemulatoradapter_test
+
+import (
+	"encoding/json"
+	"io/ioutil"
+	"net/http"
+	"os"
+	"testing"
+	"time"
+
+	log "github.com/sirupsen/logrus"
+
+	"gitpct.epam.com/epmd-aepr/aos_vis/dataadapter/telemetryemulatoradapter"
+	"gitpct.epam.com/epmd-aepr/aos_vis/dataadaptertest"
+)
+
+/*******************************************************************************
+ * Var
+ ******************************************************************************/
+
+var (
+	adapterInfo  dataadaptertest.TestAdapterInfo
+	emulatorData map[string]interface{}
+)
+
+/*******************************************************************************
+ * Init
+ ******************************************************************************/
+
+func init() {
+	log.SetFormatter(&log.TextFormatter{
+		DisableTimestamp: false,
+		TimestampFormat:  "2006-01-02 15:04:05.000",
+		FullTimestamp:    true})
+	log.SetLevel(log.DebugLevel)
+	log.SetOutput(os.Stdout)
+}
+
+/*******************************************************************************
+ * Main
+ ******************************************************************************/
+
+func TestMain(m *testing.M) {
+	startHTTPServer()
+
+	telemetryEmulatorAdapter, err := telemetryemulatoradapter.NewAdapter([]byte(`{"SensorURL":"http://localhost:8801"}`))
+	if err != nil {
+		log.Fatalf("Can't create sensor emulator adapter: %s", err)
+	}
+
+	adapterInfo = dataadaptertest.TestAdapterInfo{
+		Name:    "TelemetryEmulatorAdapter",
+		Adapter: telemetryEmulatorAdapter,
+		SetData: map[string]interface{}{
+			"Attribute.Emulator.rectangle_long0": 23.56,
+			"Attribute.Emulator.rectangle_lat0":  34.12,
+			"Attribute.Emulator.rectangle_long1": 36.87,
+			"Attribute.Emulator.rectangle_lat1":  39.21,
+			"Attribute.Emulator.to_rectangle":    true},
+		SubscribeList: []string{
+			"Attribute.Emulator.rectangle_long0",
+			"Attribute.Emulator.rectangle_lat0",
+			"Attribute.Emulator.rectangle_long1",
+			"Attribute.Emulator.rectangle_lat1",
+			"Attribute.Emulator.to_rectangle"},
+		SetSubscribeData: map[string]interface{}{
+			"Attribute.Emulator.rectangle_long0": 26.56,
+			"Attribute.Emulator.rectangle_lat0":  38.12,
+			"Attribute.Emulator.rectangle_long1": 40.87,
+			"Attribute.Emulator.rectangle_lat1":  55.21,
+			"Attribute.Emulator.to_rectangle":    false}}
+
+	ret := m.Run()
+
+	os.Exit(ret)
+}
+
+/*******************************************************************************
+ * Tests
+ ******************************************************************************/
+
+func TestGetName(t *testing.T) {
+	if err := dataadaptertest.GetName(&adapterInfo); err != nil {
+		t.Errorf("Test get name error: %s", err)
+	}
+}
+
+func TestGetPathList(t *testing.T) {
+	if err := dataadaptertest.GetPathList(&adapterInfo); err != nil {
+		t.Errorf("Test get path lis error: %s", err)
+	}
+}
+
+func TestPublicPath(t *testing.T) {
+	if err := dataadaptertest.PublicPath(&adapterInfo); err != nil {
+		t.Errorf("Test public path error: %s", err)
+	}
+}
+
+func TestGetSetData(t *testing.T) {
+	if err := dataadaptertest.GetSetData(&adapterInfo); err != nil {
+		t.Errorf("Test get set data error: %s", err)
+	}
+}
+
+func TestSubscribeUnsubscribe(t *testing.T) {
+	if err := dataadaptertest.SubscribeUnsubscribe(&adapterInfo); err != nil {
+		t.Errorf("Test subscribe unsubscribe error: %s", err)
+	}
+}
+
+/*******************************************************************************
+ * Private
+ ******************************************************************************/
+
+func statsHandler(w http.ResponseWriter, r *http.Request) {
+	if r.Method != "GET" {
+		w.WriteHeader(http.StatusNotFound)
+		return
+	}
+
+	dataJSON, err := json.Marshal(emulatorData)
+	if err != nil {
+		w.WriteHeader(http.StatusBadRequest)
+	}
+
+	w.Write(dataJSON)
+}
+
+func attributesHandler(w http.ResponseWriter, r *http.Request) {
+	if r.Method != "POST" {
+		w.WriteHeader(http.StatusNotFound)
+		return
+	}
+
+	dataJSON, err := ioutil.ReadAll(r.Body)
+	r.Body.Close()
+	if err != nil {
+		log.Error(err)
+		w.WriteHeader(http.StatusBadRequest)
+		w.Write([]byte(err.Error()))
+		return
+	}
+
+	if err = json.Unmarshal(dataJSON, &emulatorData); err != nil {
+		log.Error(err)
+		w.WriteHeader(http.StatusBadRequest)
+		w.Write([]byte(err.Error()))
+		return
+	}
+
+	w.WriteHeader(http.StatusCreated)
+}
+
+func startHTTPServer() {
+	emulatorData = map[string]interface{}{
+		"rectangle_lat0":  nil,
+		"rectangle_lat1":  nil,
+		"rectangle_long0": nil,
+		"rectangle_long1": nil,
+		"to_rectangle":    nil}
+
+	http.HandleFunc("/stats/", statsHandler)
+	http.HandleFunc("/attributes/", attributesHandler)
+	go http.ListenAndServe("localhost:8801", nil)
+
+	time.Sleep(1 * time.Second)
+}
diff --git a/dataprovider/dataprovider.go b/dataprovider/dataprovider.go
index b94adc0b535d..ae01aff855db 100644
--- a/src/gitpct.epam.com/epmd-aepr/aos_vis/dataprovider/dataprovider.go
+++ b/src/gitpct.epam.com/epmd-aepr/aos_vis/dataprovider/dataprovider.go
@@ -9,6 +9,9 @@ import (
 	"strings"
 	"sync"
 
+	"gitpct.epam.com/epmd-aepr/aos_vis/dataadapter/storageadapter"
+	"gitpct.epam.com/epmd-aepr/aos_vis/dataadapter/telemetryemulatoradapter"
+
 	log "github.com/sirupsen/logrus"
 	"gitpct.epam.com/epmd-aepr/aos_vis/config"
 	"gitpct.epam.com/epmd-aepr/aos_vis/dataadapter"
@@ -349,7 +352,19 @@ func (provider *DataProvider) createAdapter(pluginPath string, params interface{
 		return err
 	}
 
-	adapter, err := dataadapter.NewAdapter(pluginPath, paramsJSON)
+	var adapter dataadapter.DataAdapter
+
+	switch pluginPath {
+	case "storageadapter":
+		adapter, err = storageadapter.NewAdapter(paramsJSON)
+
+	case "telemetryemulatoradapter":
+		adapter, err = telemetryemulatoradapter.NewAdapter(paramsJSON)
+
+	default:
+		adapter, err = dataadapter.NewAdapter(pluginPath, paramsJSON)
+	}
+
 	if err != nil {
 		return err
 	}
-- 
2.17.1

